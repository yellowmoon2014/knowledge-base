## 状态机
有限状态机，（英语：Finite-state machine，**FSM**），又称有限状态自动机，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。它反映从系统开始到现在时刻的输入变化，转移指示状态变更，并且用必须满足来确使转移发生的条件来描述它；动作是在给定时刻要进行的活动的描述

## 行为树
行为树是一种用于任务切换的结构，于其类似的结构有有限状态机（英语：Finite-state machine，**FSM**）, 他们经常被用于机器人和游戏AI中，在这种场景下，对象的动作往往是被提前编辑好的，但在什么时间或者地点使用什么动作是不确定的。因此需要使用行为树或状态机来实现这些智能体的决策任务

相比与更早出现的状态机来说，行为树具有以下优点:

- 模块化：行为树可以随意添加或者删除动作元素。
- 表现力：我们可以组合复杂的行为，包括将整棵树作为更大树的子分支。
- 语义的图形化：行为树可以轻易的转换成图形化的流程，而状态机则相对困难。
- 更强的表现力：自带顺序，循环，中断等逻辑处理工具

## 事务
事务是并发控制单位，是用户定义的一个操作序列

## ACID
事务的4个特性
- 原子性， 事务中的操作要么全部做，要么全部不做
- 一致性， 事务执行的结果必须是从一个一致性的状态变成另外一个一致性的状态（所谓一致性是数据库处理前后结果应与其所抽象的客观世界中真实状况保持一致。这种一致性是一种需要管理员去定义的规则。管理员如何指定规则，数据库就严格按照这种规则去处理数据）
- 隔离性， 一个事务的执行不能被其它事务干扰。MySql拥有四种事务隔离级别
    - 序列化  用户不同事务在队列里面排队按顺序一个个执行，序列化提供最大的隔离
    - 可重复读 当前事务的变化不能被其他事务看到
    - 提交读   当前事务的变化可以被其他事务看到，可能导致同一个事务多次查询结果不一致
    - 未提交读  当前事务未提交的变化可以被其他事务看到
- 永久性， 一个事务一旦提交，对数据的变更是永久的

## 事务传播

## MVCC
MVCC(Multi-Version Concurrency Control) 多版本并发控制,是数据库管理系统用于支持并发访问的一种常用机制。其基本思想是:

1. 为每一个会修改数据的事务分配一个唯一的时间戳或版本号。

2. 读取事务可以读取任意版本的数据,而写事务只能读取当前版本的数据。

3. 写事务提交时会生成新版本的数据,未提交时访问到该版本数据的事务会被回滚。

4. 老版本的数据会在所有事务不再需要时被自动删除。

MVCC的工作流程如下:

1. 事务开始时获取SNAPSHOT时间戳。

2. 事务读取数据时,返回SNAPSHOT时间戳之前的版本。

3. 事务进行修改时,生成新版本数据,标记为不可见。 

4. 事务提交时,新版本数据标记为可见。

5. 其他事务如果访问到不可见版本,会被回滚重试。

6. 老版本数据在没有事务引用时被自动删除。

MVCC使读取事务不会阻塞写事务,也避免写事务间的相互影响,实现真正的无锁并发控制。它适合需要高并发的数据库场景。

## 乐观锁
假设不会发生冲突,只在提交操作时检查是否违反数据完整性。类似Java中CAS算法。但有冲突的重试代价

## 悲观锁
在修改数据之前先加锁,确保同时只有一个线程可以访问数据。类似 Java中的synchronized。但加锁的开销大,容易发生死锁

## 无锁
通过原子操作和事务内存等方式,实现锁的完全去中心化。性能高但实现复杂,适用场景较少

## 脏写
**还未提交的事务写了另一个未提交事务所写过的数据，称为脏写**

两个并发执行的事务A、B，A写了x，在A还未提交前，B也写了x，然后A提交，此时虽然B还没有提交，但是A也会发现自己写的x不见了

## 脏读
由于事务的可回滚特性，因此commit前的任何读写，都有被撤销的可能，假如某个事物读取了还未commit事务的写数据，后来对方回滚了，那么读到的就是脏数据，因为它已经不存在了。通过设置隔离级别在提交读以上解决

## 不可重复读
事务A读取一个值，但是没有对它进行任何修改，另一个并发事务B修改了这个值并且提交了，事务A再去读，发现已经不是自己第一次读到的值了，是B修改后的值，就是不可重复读。通过设置隔离级别在可重复读以上解决

## 幻读
与不可重复读非常类似，事务A查询一个范围的值，另一个并发事务B往这个范围中插入了数据并提交，然后事务A再查询相同范围，发现多了一条记录，或者某条记录被别的事务删除，事务A发现少了一条记录。通过设置隔离级别在序列化以上解决

## 写偏斜
写偏斜可以理解为事务commit之前写前提被破坏，导致写入了违反业务一致性的数据。例如，会员进行了刷卡消费，此时要计算积分，开启了事务A，读到会员等级为3，与此同时定时任务也开始了，读到会员积分为2800，已经不满足3000分应该降级为2级，然后将会员等级降级为2并且commit，由于事务A读到的等级为3，它还是按照3倍积分为会员增加了积分，会员赚了，多亏那个程序员不理解他使用的事务隔离级别，出现了业务不一致，原因就是在读取的时候数据被其它事务更改

## 读偏斜
读结果违反业务一致性，比如X、Y两个账户余额都为50，他们总和为100，事务A读X余额为50，然后事务B从X转账50到Y然后提交，事务A在B提交后读Y发现余额为100，那么它们总和变成了150，此时违反业务一致性，原因就是在读取的时候数据被其它事务更改

## 丢失更新
由于未提交事务之间看不到对方的修改，因此都以一个旧前提去更新同一个数据，导致最后的提交结果是错误值。
假设有支付宝账户X，余额100元，事务A、B同时向X分别充值10元、20元，最后结果应该为130元，但是由于丢失更新，最后是110元

## EAV建模
EAV(Entity-Attribute-Value, 实体-属性-值)是一种数据库建模方法,主要思想是:

1. 将实体(Entity)的属性(Attribute)从表结构中分离出来,定义到独立的属性表中。

2. 实体表只包含主键和属性值(Value)。

3. 为每个实体-属性对创建一条记录,存储属性值。

举例:

传统模型:

User表:

| id | name | age | gender |
|-|-|-|-| 
| 1 | 小明 | 18 | 男 |

EAV模型:

User表:

| id | attribute_id | value |
|-|-|-|
| 1 | 1 | 小明 |
| 1 | 2 | 18 |
| 1 | 3 | 男 |

Attribute表:

| id | name |
|-|-|
| 1 | name |
| 2 | age | 
| 3 | gender |

EAV模型的优点:

- 可以动态添加属性,不需要修改表结构。
- 可以为不同实体共享属性表。
- 可以轻松查询和过滤属性。

缺点:

- 查询一个实体所有属性时需要Join连接查询。
- 数据冗余,存储开销大。

适用场景:

- 需要频繁添加新属性的场景。
- 对属性进行分析统计的场景。

总体来说,EAV模型适合属性变化频繁、查询灵活的场景,但需要权衡存储空间和查询效率。

## 七大设计原则
软件设计通常遵循以下几个基本原则:

1. 单一职责原则(SRP)

一个类或模块只负责一个功能领域中的相应职责。

2. 开放封闭原则(OCP) 

软件实体(类、模块、函数等)应该对扩展开放,对修改封闭。

3. 里氏替换原则(LSP) 

任何基类可以出现的地方,子类一定可以出现。

4. 接口隔离原则(ISP)

客户端不应该依赖它不需要的接口。

5. 依赖倒转原则(DIP) 

面向接口编程,依赖于抽象而不依赖于具体。

6. 组合优于继承

优先使用组合或聚合,而不是继承。

7. 最少知识原则(迪米特法则)

一个软件实体应当尽可能少地与其他实体发生相互作用。

遵循这些基本原则,可以设计出低耦合、高内聚、稳定演进的软件系统。
